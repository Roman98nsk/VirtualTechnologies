# Лабораторная работа №1



## Сборка образа

```
$ sudo docker build -t http_server .
```
## Запуск образа на 8081 порту

```
$ sudo docker run --rm -p 8081:8000 http_server 
```
## Просмотр имеющихся образов

```
$ sudo docker images
```

# Лабораторная работа №2

## multistage

multistage - это способ получить меньшие образы Docker. Самый простой случай — это образ компилятора и образ среды выполнения: образ компилятора компилирует код, а образ среды выполнения копирует полученный артефакт. Образ среды выполнения никогда не включает слой компилятора и поэтому может быть меньше по размеру.

## GitLab CI

GitLab CI позволяет вам настраивать непрерывную интеграцию с использованием любого из образов Docker, доступного на Docker Hub.

Краткие пояснения по используемым стадиям:

- build — сборка приложения;
- testing — автотесты;
- staging — развёртывание приложения для разработчиков, DevOps, тестировщиков;
- pre-production — развёртывание в «предварительный production» для команды тестировщиков;
- approve — «предохранитель», благодаря которому релиз-инженер заказчика может отказать в развёртывании на production определённого тега;
- production — развёртывание на production.

# Лабораторная работа №3

## Docker Compose

Docker Compose — это инструментальное средство, входящее в состав Docker. Оно предназначено для решения задач, связанных с развёртыванием проектов.

## Разница между Docker и Docker Compose

Docker применяется для управления отдельными контейнерами (сервисами), из которых состоит приложение.

Docker Compose используется для одновременного управления несколькими контейнерами, входящими в состав приложения. Этот инструмент предлагает те же возможности, что и Docker, но позволяет работать с более сложными приложениями.

## Сборка проекта

```
$ sudo docker-compose build
```

## Запуск проекта

```
$ sudo docker-compose up
```
# Лабораторная работа №4

## Docker – USER 

По умолчанию контейнер Docker запускается от имени пользователя Root. Это представляет серьезную угрозу безопасности, если вы развертываете свои приложения в больших масштабах внутри контейнеров Docker. Вы можете изменить или переключиться на другого пользователя внутри контейнера Docker с помощью инструкции USER . Для этого сначала нужно создать пользователя и группу внутри Контейнера.

1. Создание Dockerfile 

Cоздаем новую группу с именем nonroot и нового пользователя внутри группы. Используя опцию USER , мы затем переключаем пользователя.

```
RUN groupadd -r nonroot && useradd -r -g nonroot nonroot 
USER nonroot
```

2. Сборка образа:

```
$ sudo docker build -t nonrootuser .
```

3. Запуск контейнер Docker:

```
$ sudo docker run -it nonrootuser /bin/bash
```

## Docker – gosu ENTRYPOINT 

1. Установить gosu:

```
$ sudo apt install gosu
```

2. Создать файл .sh, где выполняется команда chown в рамках entrypoint-скрипта, требующая права root, после чего приложение продолжает выполняться из-под пользователя redis.:

```
#!/bin/bash
set -e
if [ "$1" = 'redis-server' ];
  then
    chown -R redis . 
    exec gosu redis "$@"
  fi
exec "$@"
```

3. Dockerfile:

```
COPY docker_gosu.sh .
RUN chmod +x docker_gosu.sh
ENTRYPOINT [ "docker_gosu.sh" ]
CMD ["/bin/bash", "-c", "docker_gosu.sh"]
```

4. Запуск контейнера REDIS:

```
$ docker run --name myredis -idt redis
```

5. Вход в контейнер:

```
$ docker exec -it myredis /bin/bash
```

6. Сначала нужно обновить APT в контейнере:

```
# apt-get update
```

7. Установить команду PS:

```
# apt-get install procps
```

8. Выполненить команду для просмотра пользователя Redis 

```
# ps -ef
```

Приведенные выше результаты показывают две ключевые информации:

1. Cлужба Redis запускается с учетной записью Redis, а не root;
2. PID службы Redis равен 1, что очень важно, при выполнении команды docker stop процесс может получить семафор SIGTERM, поэтому приложение Redis может выполнить некоторые приготовления перед выходом, такие как сохранение переменных, выход петля и т.д., элегантное отключение;

Служба Redis не является учетной записью root, а процесс службы по-прежнему является процессом в контейнере.

Основная цель инструмента - запуск процессов от определенного пользователя, но в отличие от sudo и su, gosu не делает fork процессов, как показано ниже:

```
$ docker run -it --rm ubuntu:trusty su -c 'exec ps aux'
$ docker run -it --rm ubuntu:trusty sudo ps aux
$ docker run --rm gosu/alpine gosu root ps aux
```

## В чем различие в runtime при использовании инструкции USER и использовании gosu 

В случае, если злоумышленнику удастся заполучить shell внутри вашего контейнера, он может оказаться root'ом, что сильно упростит дальнейшую атаку с выходом за пределы контейнера. Чтобы избежать этого, указывайте пользователя в явном виде через инструкцию USER. Однако это работает 
только в том случае, если вашему приложению не требуется привилегии root после сборки.

Утилита gosu будет полезна, когда необходимо предоставлять root доступ после сборки Dockerfile во время инициализации, но при этом приложение должно запускаться в непривилегированном режиме.

# Лабораторная работа №5

## Добавить в Docker-compose экземпляр базы данных Postgresql 

1. Добавить сервис в docker-compose.yml:

  db_ps:
    image: postgres
    ports:
      - "5531:5531"
    environment:
      - POSTGRES_PASSWORD=root
      - POSTGRES_USER=admin

  2. Выполнить сборку и запуск docker-compose

    ```
    $ docker-compose up --build
    ```
  3. После сборки должна появиться строка, что бд готова к подключению:

    ```
    database system is ready to accept connections
    ```
## Разработка модели данных.

  1. Установка Psycopg2 с помощью pip. Для начала нужно установить текущую версию Psycopg2 для использования PostgreSQL в Python.

    ```
    $ pip install psycopg2
    ```





