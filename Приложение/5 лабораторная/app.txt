Сборка образа:
$ sudo docker build -t http_server .

Запуск образа на 8081 порту:
$ sudo docker run --rm -p 8081:8000 http_server 

Просмотр имеющихся образов:
$ sudo docker images

multistage - это способ получить меньшие образы Docker.
Самый простой случай — это образ компилятора и образ среды 
выполнения: образ компилятора компилирует код, а образ 
среды выполнения копирует полученный артефакт. 
Образ среды выполнения никогда не включает слой компилятора 
и поэтому может быть меньше по размеру.






~ Docker Compose. ~

Сборка проекта:
$ sudo docker-compose build

Запуск проекта:
$ sudo docker-compose up






~ Docker – USER ~

По умолчанию контейнер Docker запускается от имени пользователя 
Root. Это представляет серьезную угрозу безопасности, если вы 
развертываете свои приложения в больших масштабах внутри 
контейнеров Docker. Вы можете изменить или переключиться 
на другого пользователя внутри контейнера Docker с помощью 
инструкции USER . Для этого сначала нужно создать пользователя 
и группу внутри Контейнера.

1. Создание Dockerfile 

Cоздаем новую группу с именем nonroot и нового пользователя внутри 
группы. Используя опцию USER , мы затем переключаем пользователя.

RUN groupadd -r nonroot && useradd -r -g nonroot nonroot 
USER nonroot

2. Сборка образа:
$ sudo docker build -t nonrootuser .

3. Запуск контейнер Docker:
$ sudo docker run -it nonrootuser /bin/bash

~ Docker – gosu ENTRYPOINT ~

1. Установить gosu:
$ sudo apt install gosu

2. Создать файл .sh, где выполняется команда chown
в рамках entrypoint-скрипта, требующая права root, 
после чего приложение продолжает выполняться из-под 
пользователя redis.:

#!/bin/bash
set -e
if [ "$1" = 'redis-server' ];
  then
    chown -R redis . 
    exec gosu redis "$@"
  fi
exec "$@"

3. Dockerfile:

COPY docker_gosu.sh .
RUN chmod +x docker_gosu.sh
ENTRYPOINT [ "docker_gosu.sh" ]
CMD ["/bin/bash", "-c", "docker_gosu.sh"]

4. Запуск контейнера REDIS:

$ docker run --name myredis -idt redis

5. Вход в контейнер:

$ docker exec -it myredis /bin/bash

6. Сначала нужно обновить APT в контейнере:
# apt-get update

7. Установить команду PS:
# apt-get install procps

8. Выполненить команду для просмотра пользователя Redis 
# ps -ef

Приведенные выше результаты показывают две ключевые информации:
1. Cлужба Redis запускается с учетной записью Redis, а не root;
2. PID службы Redis равен 1, что очень важно, при выполнении команды
docker stop процесс может получить семафор SIGTERM, поэтому приложение 
Redis может выполнить некоторые приготовления перед выходом, 
такие как сохранение переменных, выход петля и т.д., элегантное отключение;

Служба Redis не является учетной записью root, 
а процесс службы по-прежнему является процессом в контейнере.

Основная цель инструмента - запуск процессов от определенного 
пользователя, но в отличие от sudo и su, gosu не делает fork 
процессов, как показано ниже:
$ docker run -it --rm ubuntu:trusty su -c 'exec ps aux'
$ docker run -it --rm ubuntu:trusty sudo ps aux
$ docker run --rm gosu/alpine gosu root ps aux

~ В чем различие в runtime при использовании инструкции USER и 
использовании gosu ~

В случае, если злоумышленнику удастся заполучить shell внутри вашего 
контейнера, он может оказаться root'ом, что сильно упростит дальнейшую 
атаку с выходом за пределы контейнера. Чтобы избежать этого, указывайте 
пользователя в явном виде через инструкцию USER. Однако это работает 
только в том случае, если вашему приложению не требуется 
привилегии root после сборки.

Утилита gosu будет полезна, когда необходимо предоставлять root доступ 
после сборки Dockerfile во время инициализации, но при этом приложение 
должно запускаться в непривилегированном режиме.